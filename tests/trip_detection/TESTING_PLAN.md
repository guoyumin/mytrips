# Trip Detection Testing Plan

## 测试目标

验证`backend/lib/trip_detector.py`模块的核心功能：
- 从邮件预订信息中准确检测行程边界
- 将相关预订正确组织为完整行程
- 确保输出数据结构完整且符合预期

## 测试策略

### 直接AI集成测试
- **跳过Mock**: 直接使用真实AI提供商，验证实际使用场景
- **真实数据**: 基于数据库中提取的真实预订信息构建测试用例
- **多模型验证**: 测试fast和powerful两个模型tier的表现差异
- **多提供商支持**: 确保Gemini、OpenAI、Claude三个AI提供商的兼容性

### 测试数据分级结构
```
test_data/
├── level_1_single_booking/     # 单一预订 - 最基础场景
├── level_2_multi_booking/      # 多预订单行程 - 组合场景
├── level_3_existing_trips/     # 更新已有行程 - 增量场景
├── level_4_complex_relationships/ # 预订关系处理 - 复杂场景
└── level_5_edge_cases/         # 边界情况 - 异常场景
```

## 当前实施: Level 1 - 单一预订测试

### 测试场景设计
- **基础场景**: 苏黎世往返单一目的地的简单行程
- **输入**: 单个email对象，包含完整的往返航班预订信息
- **期望**: 生成单一trip对象，正确识别行程边界和transport segments

### 关键验证点
1. **行程边界识别**: 正确识别从苏黎世出发并返回的完整行程
2. **数据映射**: booking信息正确转换为trip结构
3. **时间逻辑**: 日期和时间顺序合理
4. **费用计算**: 总费用和分项费用准确
5. **关联关系**: email_id正确关联到相关预订

## 测试实现思路

### 主要测试维度
1. **模型tier比较**: 使用相同数据测试fast vs powerful模型
2. **提供商兼容性**: 相同输入在不同AI提供商间的一致性
3. **输出质量**: AI生成结果的准确性和完整性
4. **错误处理**: 异常情况下的graceful degradation

### 验证方法
- **结构验证**: 输出JSON符合预期schema
- **内容验证**: 关键字段值的正确性
- **逻辑验证**: 时间、地点、费用的合理性
- **一致性验证**: 不同模型输出的基本一致性

## 扩展计划

### Level 2: 多预订组合
- 航班+酒店的完整行程
- 多段连接航班的复杂路线
- 不同预订类型的组合场景

### Level 3: 增量更新
- 向现有行程添加新预订
- 处理行程的延长和修改
- 费用和日期的动态更新

### Level 4: 关系处理
- 预订修改和取消的关联
- 相同确认号的多版本处理
- 原始预订与变更的追踪

### Level 5: 边界场景
- 数据缺失和格式错误
- AI响应异常的处理
- 超出正常范围的预订组合

## 执行考虑

### 成本控制
- 合理安排测试频率避免过度API调用
- 优先使用cost-effective的fast模型进行基础验证
- 在关键测试点使用powerful模型确保质量

### 性能期望
- 设置合适的timeout处理AI响应延迟
- 考虑AI输出的变异性，设置合理的验证容差
- 建立baseline用于比较不同版本的性能变化

这个测试框架从最简单的场景开始，逐步扩展到复杂情况，确保trip detector功能的全面覆盖和质量保证。